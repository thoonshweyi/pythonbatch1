=>Install Virtual Environment 
     #Linux
     sudo apt install python3-venv


=> Create Virtual Environment
     #Linux/macOS
     python3 -m venv myenv              // you can use anyname whatever you want "myenv"

     #Windows 
     py -m venv myenv

     => for activate
          #Linux/macOS
          source myenv/bin/activate // activate

          #Windows
          .\myenv\Scripts\activate      // activate
          

          pip3 list

          deactivate
          (myenv) administrator@administrator:~/Documents/class/pythonbathc1 $ deactivate 
          administrator@administrator:~/Documents/class/pythonbathc1

          pip3 list

----------------------------------------------
=> mysql module (v9.4.0)
     https://pypi.org/project/mysql-connector-python/
     
     pip install mysql-connector-python

     pip3 list

= python dotenv (v  1.1.1)
     (i) Install
     https://pypi.org/project/python-dotenv/

     pip install python-dotenv

     pip3 list

     create .env file

     (ii) Create
     create .env file

     (iii) import
          from dotenv import load_dotenv
          import os

          load_dotenv() 

-----------------------------------------------------
=> Telegram Bot (v 22.5)

     https://python-telegram-bot.org/

     pip install python-telegram-bot

     pip3 list
-----------------------------------------------------
=> Get Telegram Token Key
     (i) Google or Telegram app, find @BotFather
          https://web.telegram.org/k/#@BotFather

     (ii) Create a new bot
          click start or send /start
          Send /newbot

               BotFather will ask for:
                    Bot name for your bot = pybotl73
                    Bot username = Must end with bot = pybot73bot
     (iii) Copy your API Token
               Done! Congratulations on your new bot. You will find it at t.me/Thorn4RBot. You can now add a description, about section and profile picture for your bot, see /help for a list of commands. By the way, when you've finished creating your cool bot, ping our Bot Support if you want a better username for it. Just make sure the bot is fully operational before you do this.

               Use this token to access the HTTP API:
               8305029910:AAHS6A32aZF4opr84u1jGTsZdS7NOLshhUY
               Keep your token secure and store it safely, it can be used by anyone to control your bot.

               For a description of the Bot API, see this page: https://core.telegram.org/bots/api


          =>Simple code
               from telegram import Update
               from telegram.ext import ApplicationBuilder, CommandHandler, ContextTypes


               async def hello(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
               await update.message.reply_text(f'Hello {update.effective_user.first_name}')


               app = ApplicationBuilder().token("YOUR TOKEN HERE").build()

               app.add_handler(CommandHandler("hello", hello))

               app.run_polling()


-----------------------------------------------------

=> Create Database
     CREATE TABLE IF NOT EXISTS employees(
          id INT AUTO_INCREMENT PRIMARY KEY,
          fullname VARCHAR(225) NOT NULL,
          email VARCHAR(255) NOT NULL UNIQUE,
          created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
     )

---------------------------------------------------------------------
=Defining state constants for Telegram bots using the ConversationHandler.
     FULLNAME, EMAIL = range(2)
          💡 What it does
          The built-in Python function range(2) creates a sequence of numbers:

          python
          Copy code
          range(2)  →  [0, 1]
          Then, those two numbers are unpacked (assigned) to the two variables:

          python
          Copy code
          FULLNAME = 0
          EMAIL = 1
     In a Telegram ConversationHandler, you need to define states — identifiers that tell the bot which step of the conversation the user is currently in.

     So instead of writing numbers directly (which is unclear and error-prone), you define them with meaningful names:

     FULLNAME, EMAIL = range(2)
     Now you can use:

     states = {
          FULLNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, fullname)],
          EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, email)],
     }


     This means:

     When the bot is in the FULLNAME state (0), it waits for a text message and runs the fullname() function.

     When it’s in the EMAIL state (1), it waits for a text message and runs the email() function.

     🧩 Equivalent longer version

     If you prefer to see it clearly, this is the same as writing:

     FULLNAME = 0
     EMAIL = 1


     But the range(2) version is shorter and more elegant.



     =>🧠 What is ConversationHandler?

          The ConversationHandler manages multi-step conversations between your bot and the user.

          In a normal bot, every command or message runs independently.
          But sometimes you need to remember where the user is in a process — like registration (asking name → then email → then saving data).

          ConversationHandler allows you to define a flow (state machine) for these steps.

          🟩 1. entry_points
               entry_points=[CommandHandler("start", start)],


               Purpose: Defines how the conversation starts.

               When a user sends /start, the function start() runs.

               So in your case:

               User types /start in Telegram.

               Bot calls your start(update, context) function.

               That function replies “Welcome! Please enter your Full Name:” and returns FULLNAME (a state number like 0).

               That return FULLNAME tells ConversationHandler that the bot is now waiting for input belonging to the FULLNAME state.

          🟦 2. states
               states={
               FULLNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, fullname)],
               EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, email)],
               },


               This dictionary defines what happens at each conversation step (state).

               🧩 FULLNAME:
               FULLNAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, fullname)]


               Means: When the bot is in the FULLNAME state,

               And the user sends a message that is text (not a command like /something),

               Then call the function fullname().

               That’s why your bot reacts correctly when the user types their name — it triggers fullname().

               Inside that function:

               context.user_data["fullname"] = update.message.text
               return EMAIL


               You store the name and return the next state EMAIL, so the bot moves on.

               🧩 EMAIL:
               EMAIL: [MessageHandler(filters.TEXT & ~filters.COMMAND, email)]


               When the bot is in the EMAIL state,

               And the user sends normal text,

               Call the function email().

               Inside email(), you save data to MySQL and then return ConversationHandler.END, which ends the conversation.

               ⚙️ Filters Explained

               filters.TEXT & ~filters.COMMAND means:

               Accept text messages

               But exclude any command (anything starting with /, e.g. /cancel, /start)

               So the bot won’t accidentally treat /cancel as someone’s name or email.

     🧩 The concept

          When you create a ConversationHandler, you usually specify three things:

          entry_points → where the conversation starts

          states → what happens at each step

          fallbacks → what to do if the user wants to stop or leaves the normal flow